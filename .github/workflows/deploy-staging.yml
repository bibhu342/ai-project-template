name: Deploy to Staging

on:
  push:
    tags:
      - "v*.*.*"

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Wait for Docker image to be built
        run: |
          IMAGE_TAG="${{ github.ref_name }}"
          IMAGE_TAG="${IMAGE_TAG#v}"
          IMAGE_NAME="${{ github.repository }}"

          echo "Waiting for image ghcr.io/${IMAGE_NAME}:${IMAGE_TAG} to be available..."

          for i in {1..30}; do
            if docker manifest inspect ghcr.io/${IMAGE_NAME}:${IMAGE_TAG} > /dev/null 2>&1; then
              echo "Image found!"
              exit 0
            fi
            echo "Attempt $i: Image not yet available, waiting 10 seconds..."
            sleep 10
          done

          echo "ERROR: Image not available after 5 minutes"
          exit 1
        env:
          DOCKER_CLI_EXPERIMENTAL: enabled

      - name: Setup SSH agent, key, and known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts
          eval "$(ssh-agent -s)"
          # Add private key from secret; normalize CRLF to LF to avoid parse issues
          printf '%s' "${{ secrets.STAGING_SSH_KEY }}" | tr -d '\r' | ssh-add -
          # Also write key to a file for -i usage as a fallback
          printf '%s' "${{ secrets.STAGING_SSH_KEY }}" | tr -d '\r' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Show SSH public key and fingerprint (for server authorized_keys)
        run: |
          set -euo pipefail
          # Derive public key from the private key and print fingerprint for comparison
          ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub
          echo "::group::SSH public key fingerprint used by runner"
          ssh-keygen -lf ~/.ssh/deploy_key.pub
          echo "::endgroup::"
          echo "::group::SSH public key line to add to server authorized_keys (safe to share)"
          cat ~/.ssh/deploy_key.pub
          echo "::endgroup::"

      - name: Deploy via SSH
        env:
          SERVER: ${{ secrets.STAGING_HOST }}
          USER: ${{ secrets.STAGING_USER }}
        run: |
          # Preflight: verbose SSH to validate auth and show which key is offered
          ssh -vvv -i ~/.ssh/deploy_key -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes ${USER}@${SERVER} 'echo preflight-ok'

          # Deploy via heredoc
          ssh -i ~/.ssh/deploy_key -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes ${USER}@${SERVER} << 'ENDSSH'
            set -euo pipefail

            # Ensure ~/app exists and is a git repo
            if [ ! -d ~/app ]; then
              mkdir -p ~/app
            fi
            cd ~/app
            if [ ! -d .git ]; then
              git init
              git remote add origin ${{ github.server_url }}/${{ github.repository }}.git
            fi

            # Fetch the tag and checkout
            git fetch --depth=1 origin ${{ github.ref }}
            git checkout -B staging-deploy FETCH_HEAD

            # Navigate to deploy/staging
            cd deploy/staging

            # Verify .env.staging exists
            if [ ! -f .env.staging ]; then
              echo "ERROR: .env.staging not found"
              exit 1
            fi

            # Set image variables
            export IMAGE_NAME=${{ github.repository }}
            # Strip 'v' prefix from tag (v0.1.7 -> 0.1.7) to match GHCR image tags
            export IMAGE_TAG=${{ github.ref_name }}
            IMAGE_TAG="${IMAGE_TAG#v}"
            export IMAGE_TAG

            # Also write to .env.staging for persistence (remove old ones first)
            sed -i '/^IMAGE_NAME=/d' .env.staging
            sed -i '/^IMAGE_TAG=/d' .env.staging
            echo "IMAGE_NAME=${IMAGE_NAME}" >> .env.staging
            echo "IMAGE_TAG=${IMAGE_TAG}" >> .env.staging

            # Login to GHCR
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull latest images (ignore failures to allow first-time builds)
            docker compose pull || true

            # Run migrations
            docker compose run --rm api alembic upgrade head

            # Start services
            docker compose up -d

            # Run smoke tests
            sleep 10
            chmod +x smoke.sh
            ./smoke.sh
          ENDSSH
